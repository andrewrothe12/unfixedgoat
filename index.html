<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>SNAKE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a1a;
    color: #00f0ff;
    font-family: 'Share Tech Mono', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-user-select: none;
    user-select: none;
  }

  #game-wrapper {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas {
    display: block;
    border: 2px solid #00f0ff;
    box-shadow: 0 0 20px rgba(0,240,255,0.3), inset 0 0 20px rgba(0,240,255,0.05);
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 30px;
    font-size: 16px;
    text-shadow: 0 0 10px rgba(0,240,255,0.8);
    z-index: 10;
    pointer-events: none;
  }
  #hud span { white-space: nowrap; }
  .hud-label { color: #0088aa; }
  .hud-value { color: #00f0ff; }

  /* Overlays */
  .overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(5,5,20,0.92);
    z-index: 20;
    transition: opacity 0.3s;
  }
  .hidden { display: none !important; }

  .overlay h1 {
    font-size: 48px;
    color: #00f0ff;
    text-shadow: 0 0 30px rgba(0,240,255,0.8), 0 0 60px rgba(0,240,255,0.4);
    margin-bottom: 8px;
    letter-spacing: 6px;
  }
  .overlay h2 {
    font-size: 28px;
    color: #ff00aa;
    text-shadow: 0 0 20px rgba(255,0,170,0.6);
    margin-bottom: 30px;
  }
  .overlay .subtitle {
    font-size: 14px;
    color: #0088aa;
    margin-bottom: 30px;
  }

  .btn {
    background: transparent;
    border: 2px solid #00f0ff;
    color: #00f0ff;
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    padding: 12px 32px;
    margin: 6px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: all 0.2s;
    box-shadow: 0 0 10px rgba(0,240,255,0.2);
  }
  .btn:hover, .btn:focus {
    background: rgba(0,240,255,0.15);
    box-shadow: 0 0 20px rgba(0,240,255,0.5);
    outline: none;
  }
  .btn.accent {
    border-color: #ff00aa;
    color: #ff00aa;
    box-shadow: 0 0 10px rgba(255,0,170,0.2);
  }
  .btn.accent:hover {
    background: rgba(255,0,170,0.15);
    box-shadow: 0 0 20px rgba(255,0,170,0.5);
  }
  .btn.small { font-size: 13px; padding: 8px 20px; }

  /* Settings panel */
  .settings-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 300px;
    margin: 8px 0;
    font-size: 14px;
  }
  .settings-row label { color: #0088aa; }
  .toggle {
    width: 50px; height: 26px;
    background: #1a1a3a;
    border: 1px solid #00f0ff;
    border-radius: 13px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
  }
  .toggle.active { background: rgba(0,240,255,0.3); }
  .toggle::after {
    content: '';
    position: absolute;
    top: 3px; left: 3px;
    width: 18px; height: 18px;
    background: #00f0ff;
    border-radius: 50%;
    transition: transform 0.2s;
    box-shadow: 0 0 6px rgba(0,240,255,0.6);
  }
  .toggle.active::after { transform: translateX(24px); }

  /* Skin selector */
  .skin-grid {
    display: flex;
    gap: 12px;
    margin: 16px 0;
    flex-wrap: wrap;
    justify-content: center;
  }
  .skin-swatch {
    width: 44px; height: 44px;
    border: 2px solid #333;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    transition: all 0.2s;
  }
  .skin-swatch.locked {
    opacity: 0.3;
    cursor: not-allowed;
  }
  .skin-swatch.locked::after {
    content: 'ðŸ”’';
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%,-50%);
    font-size: 16px;
  }
  .skin-swatch.selected {
    border-color: #fff;
    box-shadow: 0 0 12px rgba(255,255,255,0.5);
  }

  /* High scores */
  .score-list {
    list-style: none;
    margin: 10px 0;
    width: 260px;
  }
  .score-list li {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
    border-bottom: 1px solid #1a1a3a;
    font-size: 14px;
  }
  .score-list .rank { color: #ff00aa; width: 30px; }
  .score-list .name { color: #00f0ff; flex: 1; }
  .score-list .pts { color: #0088aa; }

  /* Name entry */
  .name-entry {
    display: flex;
    gap: 8px;
    margin: 16px 0;
    align-items: center;
  }
  .name-entry input {
    background: #0a0a1a;
    border: 2px solid #00f0ff;
    color: #00f0ff;
    font-family: 'Share Tech Mono', monospace;
    font-size: 20px;
    width: 80px;
    text-align: center;
    padding: 6px;
    text-transform: uppercase;
    letter-spacing: 4px;
  }
  .name-entry input:focus {
    outline: none;
    box-shadow: 0 0 15px rgba(0,240,255,0.5);
  }

  /* Decay bar */
  .decay-bar-container {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 6px;
    background: #1a1a3a;
    border: 1px solid #333;
    border-radius: 3px;
    z-index: 10;
    pointer-events: none;
  }
  .decay-bar {
    height: 100%;
    background: linear-gradient(90deg, #ff00aa, #00f0ff);
    border-radius: 3px;
    transition: width 0.3s;
    box-shadow: 0 0 8px rgba(0,240,255,0.4);
  }

  /* Volume slider */
  input[type="range"] {
    -webkit-appearance: none;
    width: 120px;
    height: 6px;
    background: #1a1a3a;
    border: 1px solid #00f0ff;
    border-radius: 3px;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px; height: 16px;
    background: #00f0ff;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0,240,255,0.6);
  }
</style>
</head>
<body>
<div id="game-wrapper">
  <canvas id="game-canvas"></canvas>

  <!-- HUD -->
  <div id="hud" class="hidden">
    <span><span class="hud-label">SCORE </span><span class="hud-value" id="hud-score">0</span></span>
    <span><span class="hud-label">LENGTH </span><span class="hud-value" id="hud-length">3</span></span>
    <span><span class="hud-label">BEST </span><span class="hud-value" id="hud-best">0</span></span>
  </div>

  <!-- Decay bar -->
  <div class="decay-bar-container hidden" id="decay-bar-container">
    <div class="decay-bar" id="decay-bar" style="width:100%"></div>
  </div>

  <!-- Main Menu -->
  <div class="overlay" id="menu-screen">
    <h1>SNAKE</h1>
    <button class="btn" id="btn-start">START GAME</button>
    <button class="btn small" id="btn-skins">SKINS</button>
    <button class="btn small" id="btn-scores">HIGH SCORES</button>
    <button class="btn small" id="btn-settings">SETTINGS</button>
  </div>

  <!-- Settings -->
  <div class="overlay hidden" id="settings-screen">
    <h2>SETTINGS</h2>
    <div class="settings-row">
      <label>SPEED</label>
      <div>
        <button class="btn small" id="btn-speed">MEDIUM</button>
      </div>
    </div>
    <div class="settings-row">
      <label>MAP SIZE</label>
      <div>
        <button class="btn small" id="btn-map-size">20x20</button>
      </div>
    </div>
    <div class="settings-row">
      <label>WALL MODE</label>
      <div>
        <button class="btn small" id="btn-wall-mode">CLASSIC</button>
      </div>
    </div>
    <div class="settings-row">
      <label>MUSIC</label>
      <input type="range" id="vol-music" min="0" max="100" value="40">
    </div>
    <div class="settings-row">
      <label>SFX</label>
      <input type="range" id="vol-sfx" min="0" max="100" value="60">
    </div>
    <div style="margin-top:20px">
      <button class="btn small" id="btn-settings-back">BACK</button>
    </div>
  </div>

  <!-- Skins -->
  <div class="overlay hidden" id="skins-screen">
    <h2>SKINS</h2>
    <div class="skin-grid" id="skin-grid"></div>
    <div id="skin-info" style="font-size:13px;color:#0088aa;margin:8px 0"></div>
    <button class="btn small" id="btn-skins-back">BACK</button>
  </div>

  <!-- High Scores -->
  <div class="overlay hidden" id="scores-screen">
    <h2>HIGH SCORES</h2>
    <ol class="score-list" id="score-list"></ol>
    <button class="btn small" id="btn-scores-back">BACK</button>
  </div>

  <!-- Pause -->
  <div class="overlay hidden" id="pause-screen">
    <h2>PAUSED</h2>
    <button class="btn" id="btn-resume">RESUME</button>
    <button class="btn small" id="btn-restart-pause">RESTART</button>
    <button class="btn small accent" id="btn-quit">QUIT TO MENU</button>
  </div>

  <!-- Game Over -->
  <div class="overlay hidden" id="gameover-screen">
    <h2>GAME OVER</h2>
    <div id="go-score" style="font-size:22px;margin:10px 0"></div>
    <div id="go-unlock" style="font-size:14px;color:#ff00aa;margin:6px 0"></div>
    <div id="go-name-entry" class="hidden">
      <div style="font-size:13px;color:#0088aa;margin-bottom:6px">NEW HIGH SCORE! ENTER YOUR NAME:</div>
      <div class="name-entry">
        <input type="text" id="name-input" maxlength="3" placeholder="AAA">
        <button class="btn small" id="btn-save-score">SAVE</button>
      </div>
    </div>
    <div style="margin-top:16px">
      <button class="btn" id="btn-restart">PLAY AGAIN</button>
      <button class="btn small accent" id="btn-menu">MENU</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// AUDIO ENGINE (Web Audio API)
// ============================================================
const AudioEngine = (() => {
  let ctx = null;
  let musicGain, sfxGain;
  let musicOscillators = [];
  let musicPlaying = false;
  let musicVolume = 0.4;
  let sfxVolume = 0.6;

  function init() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    musicGain = ctx.createGain();
    musicGain.gain.value = musicVolume * 0.15;
    musicGain.connect(ctx.destination);
    sfxGain = ctx.createGain();
    sfxGain.gain.value = sfxVolume;
    sfxGain.connect(ctx.destination);
  }

  function setMusicVolume(v) {
    musicVolume = v;
    if (musicGain) musicGain.gain.value = v * 0.15;
  }

  function setSfxVolume(v) {
    sfxVolume = v;
    if (sfxGain) sfxGain.gain.value = v;
  }

  function playNote(freq, duration, type = 'square', gainVal = 0.3, target = sfxGain) {
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.setValueAtTime(gainVal, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
    osc.connect(g);
    g.connect(target);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + duration);
    return osc;
  }

  function playEat() {
    if (!ctx) return;
    playNote(880, 0.1, 'square', 0.2);
    setTimeout(() => playNote(1100, 0.1, 'square', 0.15), 50);
  }

  function playDeath() {
    if (!ctx) return;
    playNote(200, 0.4, 'sawtooth', 0.3);
    setTimeout(() => playNote(120, 0.5, 'sawtooth', 0.25), 150);
  }

  function playUnlock() {
    if (!ctx) return;
    playNote(660, 0.15, 'square', 0.2);
    setTimeout(() => playNote(880, 0.15, 'square', 0.2), 100);
    setTimeout(() => playNote(1100, 0.2, 'square', 0.2), 200);
    setTimeout(() => playNote(1320, 0.3, 'square', 0.15), 300);
  }

  function playClick() {
    if (!ctx) return;
    playNote(600, 0.05, 'square', 0.1);
  }

  // Simple synthwave arpeggio loop
  let musicInterval = null;
  const bassLine = [55, 65.41, 73.42, 82.41]; // A1, C2, D2, E2
  const arpNotes = [220, 277.18, 329.63, 440, 329.63, 277.18]; // Am arp

  function startMusic() {
    if (!ctx || musicPlaying) return;
    musicPlaying = true;
    let bassIdx = 0;
    let arpIdx = 0;
    let beat = 0;

    musicInterval = setInterval(() => {
      if (!musicPlaying) return;
      // Bass on every 4th beat
      if (beat % 4 === 0) {
        playNote(bassLine[bassIdx % bassLine.length], 0.4, 'sawtooth', 0.4, musicGain);
        bassIdx++;
      }
      // Arp on every beat
      playNote(arpNotes[arpIdx % arpNotes.length], 0.15, 'square', 0.15, musicGain);
      arpIdx++;
      beat++;
    }, 200);
  }

  function stopMusic() {
    musicPlaying = false;
    if (musicInterval) {
      clearInterval(musicInterval);
      musicInterval = null;
    }
  }

  return { init, playEat, playDeath, playUnlock, playClick, startMusic, stopMusic, setMusicVolume, setSfxVolume };
})();

// ============================================================
// GAME STATE & CONFIG
// ============================================================
let GRID_SIZE = 20;
let COLS, ROWS;

const SKINS = [
  { name: 'Cyan', color: '#00f0ff', trail: '#00f0ff', glow: 'rgba(0,240,255,', req: 0 },
  { name: 'Magenta', color: '#ff00aa', trail: '#ff00aa', glow: 'rgba(255,0,170,', req: 50 },
  { name: 'Neon Green', color: '#00ff66', trail: '#00ff66', glow: 'rgba(0,255,102,', req: 100 },
  { name: 'Flame', color: '#ff6600', trail: '#ff3300', glow: 'rgba(255,102,0,', req: 200 },
  { name: 'Rainbow', color: 'rainbow', trail: 'rainbow', glow: 'rgba(255,255,255,', req: 500 },
];

const MAP_SIZES = [
  { label: '20x20', cols: 20, rows: 20 },
  { label: '15x15', cols: 15, rows: 15 },
  { label: '10x10', cols: 10, rows: 10 },
];

const SPEED_MODES = [
  { label: 'SLOW', tick: 200 },
  { label: 'MEDIUM', tick: 160 },
  { label: 'FAST', tick: 120 },
];

let settings = {
  wallMode: 'classic', // 'classic' or 'wrap'
  musicVol: 0.4,
  sfxVol: 0.6,
  selectedSkin: 0,
  mapSize: 0, // index into MAP_SIZES
  speed: 1, // index into SPEED_MODES, default medium
};

let highScores = [];
let unlockedSkins = [true, false, false, false, false];
let bestScore = 0;

// Game variables
let snake, direction, nextDirection, food, score, snakeLength;
let gameRunning, gamePaused, gameOver;
let tickRate, tickTimer, lastTime;
let decayTimer, decayInterval, baseDecayInterval;
let particles = [];
let gridPulse = 0;
let deathFlash = 0;
let decayProgress = 1; // 1 = full, 0 = about to lose a segment

// ============================================================
// STORAGE
// ============================================================
function loadStorage() {
  try {
    const s = localStorage.getItem('snakequest_settings');
    if (s) settings = { ...settings, ...JSON.parse(s) };
    const h = localStorage.getItem('snakequest_highscores');
    if (h) highScores = JSON.parse(h);
    const u = localStorage.getItem('snakequest_unlocked');
    if (u) unlockedSkins = JSON.parse(u);
    const b = localStorage.getItem('snakequest_best');
    if (b) bestScore = parseInt(b);
  } catch(e) {}
}

function saveStorage() {
  try {
    localStorage.setItem('snakequest_settings', JSON.stringify(settings));
    localStorage.setItem('snakequest_highscores', JSON.stringify(highScores));
    localStorage.setItem('snakequest_unlocked', JSON.stringify(unlockedSkins));
    localStorage.setItem('snakequest_best', bestScore.toString());
  } catch(e) {}
}

// ============================================================
// CANVAS SETUP
// ============================================================
const canvas = document.getElementById('game-canvas');
const ctx2d = canvas.getContext('2d');

function resizeCanvas() {
  const map = MAP_SIZES[settings.mapSize];
  COLS = map.cols;
  ROWS = map.rows;
  // Scale grid cells to fit the viewport while keeping square cells
  const maxW = window.innerWidth - 40;
  const maxH = window.innerHeight - 80;
  const cellSize = Math.floor(Math.min(maxW / COLS, maxH / ROWS));
  GRID_SIZE = Math.max(16, cellSize);
  canvas.width = COLS * GRID_SIZE;
  canvas.height = ROWS * GRID_SIZE;
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
function spawnParticles(x, y, color, count = 12) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
    const speed = 1.5 + Math.random() * 3;
    particles.push({
      x: x * GRID_SIZE + GRID_SIZE / 2,
      y: y * GRID_SIZE + GRID_SIZE / 2,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.02 + Math.random() * 0.03,
      color: color,
      size: 2 + Math.random() * 3,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.96;
    p.vy *= 0.96;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx2d.globalAlpha = p.life;
    ctx2d.fillStyle = p.color;
    ctx2d.shadowColor = p.color;
    ctx2d.shadowBlur = 8;
    ctx2d.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx2d.globalAlpha = 1;
  ctx2d.shadowBlur = 0;
}

// ============================================================
// RAINBOW HELPER
// ============================================================
function rainbowColor(t) {
  const r = Math.sin(t) * 127 + 128;
  const g = Math.sin(t + 2.094) * 127 + 128;
  const b = Math.sin(t + 4.189) * 127 + 128;
  return `rgb(${r|0},${g|0},${b|0})`;
}

// ============================================================
// GAME LOGIC
// ============================================================
function initGame() {
  const startX = Math.floor(COLS / 2);
  const startY = Math.floor(ROWS / 2);
  snake = [
    { x: startX, y: startY },
    { x: startX - 1, y: startY },
    { x: startX - 2, y: startY },
  ];
  direction = { x: 1, y: 0 };
  nextDirection = { x: 1, y: 0 };
  score = 0;
  snakeLength = 3;
  tickRate = SPEED_MODES[settings.speed].tick; // ms per tick
  tickTimer = 0;
  baseDecayInterval = 3000; // ms - lose a segment every 3s
  decayInterval = baseDecayInterval;
  decayTimer = 0;
  decayProgress = 1;
  gameRunning = true;
  gamePaused = false;
  gameOver = false;
  particles = [];
  gridPulse = 0;
  deathFlash = 0;
  placeFood();
  updateHud();
}

function placeFood() {
  let attempts = 0;
  do {
    food = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS),
    };
    attempts++;
  } while (snake.some(s => s.x === food.x && s.y === food.y) && attempts < 1000);
}

function tick() {
  // Apply buffered direction
  direction = { ...nextDirection };

  // Calculate new head
  let newX = snake[0].x + direction.x;
  let newY = snake[0].y + direction.y;

  // Wall handling
  if (settings.wallMode === 'wrap') {
    newX = (newX + COLS) % COLS;
    newY = (newY + ROWS) % ROWS;
  } else {
    if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) {
      die();
      return;
    }
  }

  // Self collision
  if (snake.some(s => s.x === newX && s.y === newY)) {
    die();
    return;
  }

  // Move
  snake.unshift({ x: newX, y: newY });

  // Eat food?
  if (newX === food.x && newY === food.y) {
    score += 10;
    snakeLength++;
    // Reset decay timer on eat
    decayTimer = 0;
    decayProgress = 1;
    // Accelerate decay: reduce interval by 2% per food, min 800ms
    decayInterval = Math.max(800, decayInterval * 0.98);

    const skin = SKINS[settings.selectedSkin];
    const pColor = skin.color === 'rainbow' ? rainbowColor(Date.now() * 0.003) : skin.color;
    spawnParticles(food.x, food.y, pColor, 15);
    gridPulse = 1;
    AudioEngine.playEat();
    placeFood();
    updateHud();
    checkUnlocks();
  }

  // Trim tail to snakeLength
  while (snake.length > snakeLength) {
    snake.pop();
  }
}

function decayTick(dt) {
  if (!gameRunning || gamePaused || gameOver) return;
  decayTimer += dt;
  decayProgress = 1 - (decayTimer / decayInterval);
  decayProgress = Math.max(0, Math.min(1, decayProgress));

  if (decayTimer >= decayInterval) {
    decayTimer = 0;
    decayProgress = 1;
    snakeLength--;
    if (snakeLength <= 1) {
      die();
      return;
    }
    // Trim the snake
    while (snake.length > snakeLength) {
      snake.pop();
    }
    updateHud();
  }
}

function die() {
  gameRunning = false;
  gameOver = true;
  deathFlash = 1;
  AudioEngine.playDeath();
  AudioEngine.stopMusic();

  if (score > bestScore) bestScore = score;
  updateHud();

  // Check if high score
  const isHighScore = highScores.length < 10 || score > (highScores[highScores.length - 1]?.score || 0);

  setTimeout(() => {
    showScreen('gameover-screen');
    document.getElementById('go-score').textContent = `SCORE: ${score}`;
    const entry = document.getElementById('go-name-entry');
    if (isHighScore && score > 0) {
      entry.classList.remove('hidden');
      document.getElementById('name-input').value = '';
      document.getElementById('name-input').focus();
    } else {
      entry.classList.add('hidden');
    }

    // Show any new unlocks
    const unlockMsg = getNewUnlocks();
    document.getElementById('go-unlock').textContent = unlockMsg;

    saveStorage();
  }, 600);
}

function checkUnlocks() {
  let newUnlock = false;
  SKINS.forEach((skin, i) => {
    if (!unlockedSkins[i] && score >= skin.req) {
      unlockedSkins[i] = true;
      newUnlock = true;
    }
  });
  if (newUnlock) {
    AudioEngine.playUnlock();
    saveStorage();
  }
}

function getNewUnlocks() {
  const msgs = [];
  SKINS.forEach((skin, i) => {
    if (score >= skin.req && i > 0) {
      msgs.push(skin.name);
    }
  });
  if (msgs.length > 0) return `UNLOCKED: ${msgs.join(', ')}`;
  return '';
}

function updateHud() {
  document.getElementById('hud-score').textContent = score;
  document.getElementById('hud-length').textContent = snakeLength;
  document.getElementById('hud-best').textContent = bestScore;
}

// ============================================================
// RENDERING
// ============================================================
function draw() {
  const w = canvas.width;
  const h = canvas.height;

  // Clear
  ctx2d.fillStyle = '#0a0a1a';
  ctx2d.fillRect(0, 0, w, h);

  // Grid
  drawGrid();

  // Food
  drawFood();

  // Snake
  drawSnake();

  // Particles
  drawParticles();

  // Death flash
  if (deathFlash > 0) {
    ctx2d.globalAlpha = deathFlash * 0.4;
    ctx2d.fillStyle = '#ff0044';
    ctx2d.fillRect(0, 0, w, h);
    ctx2d.globalAlpha = 1;
  }

  // Decay bar
  const bar = document.getElementById('decay-bar');
  bar.style.width = (decayProgress * 100) + '%';
  if (decayProgress < 0.3) {
    bar.style.background = 'linear-gradient(90deg, #ff0044, #ff00aa)';
  } else {
    bar.style.background = 'linear-gradient(90deg, #ff00aa, #00f0ff)';
  }
}

function drawGrid() {
  // Subtle cell background alternation for readability
  for (let x = 0; x < COLS; x++) {
    for (let y = 0; y < ROWS; y++) {
      if ((x + y) % 2 === 0) {
        ctx2d.fillStyle = 'rgba(0,240,255,0.015)';
        ctx2d.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
      }
    }
  }

  // Grid lines
  const pulseAlpha = 0.15 + gridPulse * 0.12;
  ctx2d.strokeStyle = `rgba(0,240,255,${pulseAlpha})`;
  ctx2d.lineWidth = 1;

  for (let x = 0; x <= COLS; x++) {
    ctx2d.beginPath();
    ctx2d.moveTo(x * GRID_SIZE + 0.5, 0);
    ctx2d.lineTo(x * GRID_SIZE + 0.5, canvas.height);
    ctx2d.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx2d.beginPath();
    ctx2d.moveTo(0, y * GRID_SIZE + 0.5);
    ctx2d.lineTo(canvas.width, y * GRID_SIZE + 0.5);
    ctx2d.stroke();
  }
}

function drawFood() {
  const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
  const cx = food.x * GRID_SIZE + GRID_SIZE / 2;
  const cy = food.y * GRID_SIZE + GRID_SIZE / 2;
  const r = GRID_SIZE / 2 - 2;

  ctx2d.shadowColor = '#ff00aa';
  ctx2d.shadowBlur = 15 * pulse;
  ctx2d.fillStyle = '#ff00aa';
  ctx2d.beginPath();
  ctx2d.arc(cx, cy, r * pulse, 0, Math.PI * 2);
  ctx2d.fill();

  // Inner bright core
  ctx2d.shadowBlur = 0;
  ctx2d.fillStyle = '#ff66cc';
  ctx2d.beginPath();
  ctx2d.arc(cx, cy, r * 0.4 * pulse, 0, Math.PI * 2);
  ctx2d.fill();
  ctx2d.shadowBlur = 0;
}

function drawSnake() {
  const skin = SKINS[settings.selectedSkin];
  const len = snake.length;

  for (let i = len - 1; i >= 0; i--) {
    const seg = snake[i];
    const t = i / Math.max(len - 1, 1);

    let color;
    if (skin.color === 'rainbow') {
      color = rainbowColor(Date.now() * 0.003 + i * 0.3);
    } else {
      color = skin.color;
    }

    // Fade tail segments that are about to decay
    let alpha = 1;
    if (i === len - 1 && len > 1) {
      // Last segment fades based on decay progress
      alpha = decayProgress;
    } else if (i > len * 0.7) {
      alpha = 0.5 + 0.5 * (1 - (i - len * 0.7) / (len * 0.3));
    }

    const x = seg.x * GRID_SIZE + 1;
    const y = seg.y * GRID_SIZE + 1;
    const s = GRID_SIZE - 2;

    ctx2d.globalAlpha = alpha;

    // Glow
    if (i === 0) {
      ctx2d.shadowColor = color;
      ctx2d.shadowBlur = 15;
    } else {
      ctx2d.shadowColor = color;
      ctx2d.shadowBlur = 6 * alpha;
    }

    ctx2d.fillStyle = color;
    ctx2d.fillRect(x, y, s, s);

    // Head highlight
    if (i === 0) {
      ctx2d.fillStyle = 'rgba(255,255,255,0.4)';
      ctx2d.fillRect(x + 2, y + 2, s - 4, s - 4);
    }
  }

  ctx2d.globalAlpha = 1;
  ctx2d.shadowBlur = 0;
}

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  if (gameRunning && !gamePaused) {
    tickTimer += dt;
    while (tickTimer >= tickRate) {
      tick();
      tickTimer -= tickRate;
      if (!gameRunning) break;
    }
    decayTick(dt);
  }

  // Update effects
  updateParticles();
  if (gridPulse > 0) gridPulse *= 0.93;
  if (gridPulse < 0.01) gridPulse = 0;
  if (deathFlash > 0) deathFlash *= 0.95;
  if (deathFlash < 0.01) deathFlash = 0;

  draw();
  requestAnimationFrame(gameLoop);
}

// ============================================================
// INPUT
// ============================================================
document.addEventListener('keydown', (e) => {
  if (gameOver) return;

  const key = e.key;

  // Pause
  if ((key === 'p' || key === 'P' || key === 'Escape') && gameRunning) {
    e.preventDefault();
    togglePause();
    return;
  }

  if (gamePaused) return;

  // Direction (prevent 180-degree turns)
  let newDir = null;
  if ((key === 'ArrowUp' || key === 'w' || key === 'W') && direction.y === 0) {
    newDir = { x: 0, y: -1 };
  } else if ((key === 'ArrowDown' || key === 's' || key === 'S') && direction.y === 0) {
    newDir = { x: 0, y: 1 };
  } else if ((key === 'ArrowLeft' || key === 'a' || key === 'A') && direction.x === 0) {
    newDir = { x: -1, y: 0 };
  } else if ((key === 'ArrowRight' || key === 'd' || key === 'D') && direction.x === 0) {
    newDir = { x: 1, y: 0 };
  }

  if (newDir) {
    e.preventDefault();
    nextDirection = newDir;
  }
});

// Touch / swipe
let touchStartX = 0, touchStartY = 0;

document.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, { passive: true });

document.addEventListener('touchend', (e) => {
  if (!gameRunning || gamePaused || gameOver) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);

  if (Math.max(absDx, absDy) < 20) return; // Too short

  if (absDx > absDy) {
    if (dx > 0 && direction.x === 0) nextDirection = { x: 1, y: 0 };
    else if (dx < 0 && direction.x === 0) nextDirection = { x: -1, y: 0 };
  } else {
    if (dy > 0 && direction.y === 0) nextDirection = { x: 0, y: 1 };
    else if (dy < 0 && direction.y === 0) nextDirection = { x: 0, y: -1 };
  }
});

// ============================================================
// UI NAVIGATION
// ============================================================
function showScreen(id) {
  document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
  document.getElementById(id).classList.remove('hidden');

  const isGame = id === 'none';
  document.getElementById('hud').classList.toggle('hidden', !isGame);
  document.getElementById('decay-bar-container').classList.toggle('hidden', !isGame);
}

function showGame() {
  document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('decay-bar-container').classList.remove('hidden');
}

function togglePause() {
  if (gameOver) return;
  gamePaused = !gamePaused;
  if (gamePaused) {
    showScreen('pause-screen');
    AudioEngine.stopMusic();
  } else {
    showGame();
    AudioEngine.startMusic();
  }
}

function startGame() {
  AudioEngine.init();
  resizeCanvas();
  initGame();
  showGame();
  AudioEngine.startMusic();
}

// ============================================================
// BUTTON HANDLERS
// ============================================================
document.getElementById('btn-start').addEventListener('click', () => {
  AudioEngine.init();
  AudioEngine.playClick();
  startGame();
});

document.getElementById('btn-settings').addEventListener('click', () => {
  AudioEngine.init();
  AudioEngine.playClick();
  showScreen('settings-screen');
  updateSettingsUI();
});

document.getElementById('btn-settings-back').addEventListener('click', () => {
  AudioEngine.playClick();
  showScreen('menu-screen');
  saveStorage();
});

document.getElementById('btn-skins').addEventListener('click', () => {
  AudioEngine.init();
  AudioEngine.playClick();
  showScreen('skins-screen');
  renderSkins();
});

document.getElementById('btn-skins-back').addEventListener('click', () => {
  AudioEngine.playClick();
  showScreen('menu-screen');
  saveStorage();
});

document.getElementById('btn-scores').addEventListener('click', () => {
  AudioEngine.init();
  AudioEngine.playClick();
  showScreen('scores-screen');
  renderScores();
});

document.getElementById('btn-scores-back').addEventListener('click', () => {
  AudioEngine.playClick();
  showScreen('menu-screen');
});

document.getElementById('btn-resume').addEventListener('click', () => {
  AudioEngine.playClick();
  togglePause();
});

document.getElementById('btn-restart-pause').addEventListener('click', () => {
  AudioEngine.playClick();
  startGame();
});

document.getElementById('btn-quit').addEventListener('click', () => {
  AudioEngine.playClick();
  AudioEngine.stopMusic();
  gameRunning = false;
  gameOver = false;
  gamePaused = false;
  showScreen('menu-screen');
});

document.getElementById('btn-restart').addEventListener('click', () => {
  AudioEngine.playClick();
  startGame();
});

document.getElementById('btn-menu').addEventListener('click', () => {
  AudioEngine.playClick();
  showScreen('menu-screen');
});

document.getElementById('btn-save-score').addEventListener('click', () => {
  const name = document.getElementById('name-input').value.toUpperCase() || 'AAA';
  highScores.push({ name: name.substring(0, 3), score });
  highScores.sort((a, b) => b.score - a.score);
  highScores = highScores.slice(0, 10);
  saveStorage();
  document.getElementById('go-name-entry').classList.add('hidden');
  AudioEngine.playClick();
});

document.getElementById('name-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    document.getElementById('btn-save-score').click();
  }
});

// Speed toggle
document.getElementById('btn-speed').addEventListener('click', () => {
  AudioEngine.playClick();
  settings.speed = (settings.speed + 1) % SPEED_MODES.length;
  updateSettingsUI();
  saveStorage();
});

// Map size toggle
document.getElementById('btn-map-size').addEventListener('click', () => {
  AudioEngine.playClick();
  settings.mapSize = (settings.mapSize + 1) % MAP_SIZES.length;
  updateSettingsUI();
  saveStorage();
});

// Wall mode toggle
document.getElementById('btn-wall-mode').addEventListener('click', () => {
  AudioEngine.playClick();
  settings.wallMode = settings.wallMode === 'classic' ? 'wrap' : 'classic';
  updateSettingsUI();
  saveStorage();
});

// Volume controls
document.getElementById('vol-music').addEventListener('input', (e) => {
  settings.musicVol = e.target.value / 100;
  AudioEngine.setMusicVolume(settings.musicVol);
  saveStorage();
});

document.getElementById('vol-sfx').addEventListener('input', (e) => {
  settings.sfxVol = e.target.value / 100;
  AudioEngine.setSfxVolume(settings.sfxVol);
  saveStorage();
});

function updateSettingsUI() {
  document.getElementById('btn-speed').textContent = SPEED_MODES[settings.speed].label;
  document.getElementById('btn-map-size').textContent = MAP_SIZES[settings.mapSize].label;
  document.getElementById('btn-wall-mode').textContent =
    settings.wallMode === 'classic' ? 'CLASSIC (DEATH)' : 'WRAP AROUND';
  document.getElementById('vol-music').value = settings.musicVol * 100;
  document.getElementById('vol-sfx').value = settings.sfxVol * 100;
}

// ============================================================
// SKINS UI
// ============================================================
function renderSkins() {
  const grid = document.getElementById('skin-grid');
  grid.innerHTML = '';
  SKINS.forEach((skin, i) => {
    const div = document.createElement('div');
    div.className = 'skin-swatch';
    if (!unlockedSkins[i]) div.classList.add('locked');
    if (settings.selectedSkin === i) div.classList.add('selected');

    if (skin.color === 'rainbow') {
      div.style.background = 'linear-gradient(135deg, #ff0000, #ff8800, #ffff00, #00ff00, #0088ff, #8800ff)';
    } else {
      div.style.background = skin.color;
    }

    div.addEventListener('click', () => {
      if (!unlockedSkins[i]) return;
      AudioEngine.playClick();
      settings.selectedSkin = i;
      saveStorage();
      renderSkins();
    });

    grid.appendChild(div);
  });

  const info = document.getElementById('skin-info');
  const current = SKINS[settings.selectedSkin];
  info.textContent = `SELECTED: ${current.name}`;
  if (!unlockedSkins[settings.selectedSkin]) {
    info.textContent += ` (LOCKED â€” NEED SCORE ${current.req})`;
  }

  // Show unlock requirements
  const locked = SKINS.filter((s, i) => !unlockedSkins[i]);
  if (locked.length > 0) {
    info.textContent += ` | NEXT UNLOCK: SCORE ${locked[0].req} (${locked[0].name})`;
  }
}

// ============================================================
// SCORES UI
// ============================================================
function renderScores() {
  const list = document.getElementById('score-list');
  list.innerHTML = '';
  if (highScores.length === 0) {
    const li = document.createElement('li');
    li.innerHTML = '<span style="color:#333">NO SCORES YET</span>';
    list.appendChild(li);
    return;
  }
  highScores.forEach((entry, i) => {
    const li = document.createElement('li');
    li.innerHTML = `<span class="rank">${i + 1}.</span><span class="name">${entry.name}</span><span class="pts">${entry.score}</span>`;
    list.appendChild(li);
  });
}

// ============================================================
// INIT
// ============================================================
loadStorage();
resizeCanvas();
window.addEventListener('resize', () => {
  if (!gameRunning || gamePaused) resizeCanvas();
});

// Start render loop (menu is visible, game not running)
gameRunning = false;
gamePaused = false;
gameOver = false;
snake = [{ x: 0, y: 0 }];
food = { x: -1, y: -1 };
score = 0;
snakeLength = 1;
decayProgress = 1;
lastTime = null;

document.getElementById('hud-best').textContent = bestScore;

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
